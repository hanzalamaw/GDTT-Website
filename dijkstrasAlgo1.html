<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ðŸ”¥ Dijkstra Maze Visualizer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

    body {
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      background: radial-gradient(circle at center, #0d0d0d 0%, #000 100%);
      color: #fff;
      margin: 0;
      overflow-x: hidden;
    }

    h1 {
      margin-top: 1rem;
      font-size: 1.8rem;
      letter-spacing: 1px;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(40, 20px);
      grid-template-rows: repeat(30, 20px);
      gap: 2px;
      margin-top: 2rem;
      border: 2px solid #222;
      background: #111;
      box-shadow: 0 0 20px rgba(0,255,255,0.2);
    }

    .cell {
      width: 20px;
      height: 20px;
      background: #1b1b1b;
      border-radius: 3px;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .cell:hover {
      background: #2a2a2a;
      cursor: pointer;
    }

    .wall {
      background: #333;
      box-shadow: inset 0 0 5px #000;
    }

    .start {
      background: #00ff66;
      box-shadow: 0 0 10px #00ff66;
    }

    .end {
      background: #ff004c;
      box-shadow: 0 0 10px #ff004c;
    }

    .visited {
      background: #007bff;
      box-shadow: 0 0 8px #007bff;
      animation: visitedAnim 0.2s;
    }

    .path {
      background: #ffff00;
      box-shadow: 0 0 12px #ffff00;
      animation: pathAnim 0.3s alternate infinite;
    }

    @keyframes visitedAnim {
      from { transform: scale(0.8); background: #001f3f; }
      to { transform: scale(1); background: #007bff; }
    }

    @keyframes pathAnim {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }

    #instructions {
      text-align: center;
      margin-top: 1.5rem;
      line-height: 1.6;
      font-size: 0.95rem;
      color: #ccc;
    }

    #instructions b {
      color: #00ffff;
    }

    footer {
      margin-top: 2rem;
      font-size: 0.8rem;
      color: #444;
    }
  </style>
</head>
<body>
  <h1>ðŸš§ Dijkstra Maze Visualizer</h1>
  <div id="grid"></div>
  <div id="instructions">
    <p>ðŸŸ¢ Press <b>S</b> + Click to set <b>Start</b></p>
    <p>ðŸ”´ Press <b>E</b> + Click to set <b>End</b></p>
    <p>âš¡ Press <b>Space</b> to Run | <b>C</b> to Reset</p>
  </div>
  <footer>Made with ðŸ’» + â˜• by Hanzala</footer>

  <script>
    const grid = document.getElementById("grid");
    const maze = [
      // 40x30 "Insanely Hard" Maze; 0 = path, 1 = wall
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1],
      [1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],
      [1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
      [1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1],
      [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
      [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],
      [1,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1],
      [1,0,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1],
      [1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
      [1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1],
      [1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
      [1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    const rows = maze.length;
    const cols = maze[0].length;
    const cells = [];
    let mode = 'none', start = null, end = null;

    // Adjust grid dynamically
    grid.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
    grid.style.gridTemplateRows = `repeat(${rows}, 20px)`;

    for (let r = 0; r < rows; r++) {
      cells[r] = [];
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        if (maze[r][c] === 1) cell.classList.add("wall");
        grid.appendChild(cell);
        cells[r][c] = { el: cell, row: r, col: c, wall: maze[r][c] === 1, dist: Infinity, prev: null, visited: false };
        cell.addEventListener("click", () => handleClick(r, c));
      }
    }

    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === 's') mode = 'start';
      else if (e.key.toLowerCase() === 'e') mode = 'end';
      else if (e.key === ' ') runDijkstra();
      else if (e.key.toLowerCase() === 'c') resetGrid();
    });

    function handleClick(r, c) {
      const cell = cells[r][c];
      if (cell.wall) return;
      if (mode === 'start') {
        if (start) start.el.classList.remove('start');
        start = cell;
        cell.el.classList.add('start');
      } else if (mode === 'end') {
        if (end) end.el.classList.remove('end');
        end = cell;
        cell.el.classList.add('end');
      }
      mode = 'none';
    }

    function resetGrid() {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = cells[r][c];
          cell.el.className = 'cell';
          if (maze[r][c] === 1) cell.el.classList.add("wall");
          Object.assign(cell, { dist: Infinity, prev: null, visited: false });
        }
      }
      start = end = null;
    }

    async function runDijkstra() {
      if (!start || !end) return alert("Set start and end first!");
      const queue = [start];
      start.dist = 0;

      while (queue.length > 0) {
        queue.sort((a, b) => a.dist - b.dist);
        const curr = queue.shift();
        if (curr.visited || curr.wall) continue;
        curr.visited = true;
        if (curr !== start && curr !== end) {
          curr.el.classList.add("visited");
          await sleep(10);
        }

        if (curr === end) break;
        for (let n of getNeighbors(curr)) {
          const alt = curr.dist + 1;
          if (alt < n.dist) {
            n.dist = alt;
            n.prev = curr;
            queue.push(n);
          }
        }
      }

      let p = end;
      while (p.prev && p !== start) {
        p = p.prev;
        if (p !== start) p.el.classList.add("path");
        await sleep(20);
      }
    }

    function getNeighbors(cell) {
      const { row, col } = cell;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      return dirs.map(([dr,dc]) => cells[row+dr]?.[col+dc]).filter(Boolean);
    }

    const sleep = ms => new Promise(res => setTimeout(res, ms));
  </script>
</body>
</html>
